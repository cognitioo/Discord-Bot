# ==========================================================
# Spam Prevention Cog for discord.py
# Originally generated by ChatGPT (OpenAI) for cognitioo (GitHub)
# This is a feature module (not a full bot).
# To use: place this file next to your bot.py and load it.
# ==========================================================

import re
import time
import asyncio
from collections import defaultdict, deque

import discord
from discord.ext import commands

URL_RE = re.compile(r'https?://\S+')

class SpamPrevention(commands.Cog):
    """
    Spam prevention Cog for discord.py.
    - Tracks recent messages per user (timestamps + content)
    - Detects: fast-rate spam, duplicate message spam, mass-mention spam, link spam
    - Actions: warn -> mute role -> kick -> ban (configurable)
    - Public method check_message(message) provided so you can call it from your own on_message
    """

    def __init__(self, bot: commands.Bot):
        self.bot = bot

        # CONFIG - tweak these to your needs
        self.window_seconds = 7            
        self.message_threshold = 5         
        self.duplicate_threshold = 4      
        self.mention_threshold = 6        
        self.link_threshold = 3           
        self.muted_role_name = "Muted"    
        self.warns_before_mute = 1
        self.mute_duration_seconds = 300  
        self.max_strikes_before_kick = 2
        self.max_strikes_before_ban = 4

        # runtime state
        # user_history[guild_id][member_id] -> deque of (timestamp, content, has_link, mention_count)
        self.user_history = defaultdict(lambda: defaultdict(lambda: deque()))
        # user_strikes[guild_id][member_id] -> int
        self.user_strikes = defaultdict(lambda: defaultdict(int))
        # tasks to unmute: (guild_id, member_id) -> asyncio.Task
        self.unmute_tasks = {}

    async def check_message(self, message: discord.Message):
        """
        Public method: call this from your own on_message if you override it.
        Example:
            @bot.event
            async def on_message(message):
                await bot.process_commands(message)
                await bot.get_cog("SpamPrevention").check_message(message)
        """
        # call the internal listener so integration is simple
        await self._process_message(message)


    @commands.Cog.listener()
    async def on_message(self, message: discord.Message):
        await self._process_message(message)

    # core processing
    async def _process_message(self, message: discord.Message):
        # ignore bots, webhooks, and DMs
        if message.author.bot or message.webhook_id is not None:
            return
        if message.guild is None:
            return

        guild = message.guild
        member = message.author
        now = time.monotonic()

        hist = self.user_history[guild.id][member.id]

        # record message attributes
        content = (message.content or "").strip()
        has_link = bool(URL_RE.search(content))
        mention_count = len(message.mentions) + len(message.role_mentions)

        hist.append((now, content, has_link, mention_count))

        # drop old entries outside the window
        while hist and (now - hist[0][0]) > self.window_seconds:
            hist.popleft()

        # quick checks
        msgs_in_window = len(hist)
        # duplicate check: count occurrences of the latest message content in the window
        dup_count = sum(1 for (_t, c, _l, _m) in hist if c != "" and c == content)
        # link count in window
        links_in_window = sum(1 for (_t, _c, l, _m) in hist if l)
        # max mentions in latest message
        latest_mentions = mention_count

        # conditions for spam
        is_fast_spam = msgs_in_window >= self.message_threshold
        is_dup_spam = content != "" and dup_count >= self.duplicate_threshold
        is_link_spam = links_in_window >= self.link_threshold
        is_mention_spam = latest_mentions >= self.mention_threshold

        # If flagged, take action
        if is_fast_spam or is_dup_spam or is_link_spam or is_mention_spam:
            reason_components = []
            if is_fast_spam:
                reason_components.append(f"{msgs_in_window} msgs in {self.window_seconds}s")
            if is_dup_spam:
                reason_components.append(f"{dup_count} duplicate msgs")
            if is_link_spam:
                reason_components.append(f"{links_in_window} links in window")
            if is_mention_spam:
                reason_components.append(f"{latest_mentions} mentions")

            reason = "Spam detected: " + " | ".join(reason_components)

            # remove the offending message quickly where possible
            try:
                await message.delete()
            except Exception:
                pass  # missing perms or already deleted

            await self._handle_action(guild, member, message.channel, reason)

    async def _handle_action(self, guild: discord.Guild, member: discord.Member,
                             channel: discord.abc.Messageable, reason: str):
        gid = guild.id
        mid = member.id

        # increment strikes
        self.user_strikes[gid][mid] += 1
        strikes = self.user_strikes[gid][mid]

        # actions by strike level
        try:
            if strikes <= self.warns_before_mute:
                # Warn
                try:
                    await member.send(f"You were warned in **{guild.name}** for: {reason}")
                except Exception:
                    # can't DM - send ephemeral channel warn
                    await channel.send(f"{member.mention} â€” Please stop spamming. (Warned)")
                return

            if strikes <= self.max_strikes_before_kick:
                # Mute (temporary)
                await self._apply_mute(guild, member, self.mute_duration_seconds, reason, channel)
                return

            if strikes <= self.max_strikes_before_ban:
                # Kick
                try:
                    await guild.kick(member, reason=reason)
                    await channel.send(f"{member} was kicked for repeated spam.")
                except Exception:
                    await channel.send("Failed to kick (missing permissions).")
                return


            try:
                await guild.ban(member, reason=reason, delete_message_days=1)
                await channel.send(f"{member} was banned for repeated spam.")
            except Exception:
                await channel.send("Failed to ban (missing permissions).")
        except Exception as ex:
            # safety catch-all
            try:
                await channel.send(f"Spam handling failed: {ex}")
            except Exception:
                pass

    async def _apply_mute(self, guild: discord.Guild, member: discord.Member,
                          duration: int, reason: str, channel: discord.abc.Messageable):
        """Find or create a Muted role and give it to the member for duration seconds."""
        # find role
        muted_role = discord.utils.get(guild.roles, name=self.muted_role_name)
        if muted_role is None:
            # try to create role
            try:
                muted_role = await guild.create_role(name=self.muted_role_name, reason="Create muted role for spam prevention")
                # set permissions on all channels to deny send_messages for the role
                for ch in guild.channels:
                    try:
                        await ch.set_permissions(muted_role, send_messages=False, speak=False, add_reactions=False)
                    except Exception:
                        pass
            except Exception:
                muted_role = None

        if muted_role is None:
            # fallback: try to timeout (discord.py 2.0+ supports Member.edit(timeout=...))
            # If API doesn't support timeout or missing perms, notify
            try:
                # discord.Member.edit supports communication_disabled_until for timed out users
                if hasattr(member, "timeout") or hasattr(member, "communication_disabled_until"):
                    # using Member.edit to set timeout
                    until = discord.utils.utcnow() + discord.timedelta(seconds=duration)
                    await member.edit(communication_disabled_until=until, reason=reason)
                    await channel.send(f"{member.mention} has been timed out for {duration//60}m for spam.")
                    # schedule unmute is not necessary for timeout
                    return
            except Exception:
                await channel.send("Could not mute or timeout user (missing perms or unsupported).")
                return

        # add role
        try:
            await member.add_roles(muted_role, reason=reason)
            await channel.send(f"{member.mention} has been muted for {duration//60} minutes for spam.")
        except Exception:
            await channel.send("Failed to add muted role (missing permissions).")
            return

        # schedule unmute
        task_key = (guild.id, member.id)
        if task_key in self.unmute_tasks:
            self.unmute_tasks[task_key].cancel()

        task = self.bot.loop.create_task(self._scheduled_unmute(guild.id, member.id, duration))
        self.unmute_tasks[task_key] = task

    async def _scheduled_unmute(self, guild_id: int, member_id: int, duration: int):
        try:
            await asyncio.sleep(duration)
            guild = self.bot.get_guild(guild_id)
            if guild is None:
                return
            member = guild.get_member(member_id)
            if member is None:
                return

            muted_role = discord.utils.get(guild.roles, name=self.muted_role_name)
            if muted_role and muted_role in member.roles:
                try:
                    await member.remove_roles(muted_role, reason="Automatic unmute after spam mute duration")
                    # attempt to inform in system channel if exists
                    if guild.system_channel:
                        await guild.system_channel.send(f"{member.mention} has been unmuted.")
                except Exception:
                    pass
        finally:
            self.unmute_tasks.pop((guild_id, member_id), None)


    @commands.command(name="resetstrikes")
    @commands.has_permissions(manage_guild=True)
    async def reset_strikes(self, ctx: commands.Context, member: discord.Member = None):
        """Reset strikes for a member (or for the whole guild if no member provided)."""
        if member:
            self.user_strikes[ctx.guild.id].pop(member.id, None)
            await ctx.send(f"Strikes reset for {member}.")
        else:
            self.user_strikes[ctx.guild.id].clear()
            await ctx.send("All strikes reset for this guild.")

    @commands.command(name="spamset")
    @commands.has_permissions(manage_guild=True)
    async def spam_set(self, ctx: commands.Context, key: str, value: int):
        """
        Basic runtime config change (very small convenience).
        keys: window, threshold, dup, mentions, link, muteMinutes
        Example: !spamset threshold 6
        """
        key = key.lower()
        if key == "window":
            self.window_seconds = int(value)
        elif key == "threshold":
            self.message_threshold = int(value)
        elif key == "dup":
            self.duplicate_threshold = int(value)
        elif key == "mentions":
            self.mention_threshold = int(value)
        elif key == "link":
            self.link_threshold = int(value)
        elif key == "muteminutes":
            self.mute_duration_seconds = int(value) * 60
        else:
            await ctx.send("Unknown key.")
            return
        await ctx.send(f"Set {key} to {value}.")

def setup(bot):
    bot.add_cog(SpamPrevention(bot))


async def setup(bot):
    await bot.add_cog(SpamPrevention(bot))
